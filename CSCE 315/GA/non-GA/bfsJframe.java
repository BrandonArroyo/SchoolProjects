

/**
 *
 * @authors Bodey Brandon
 * utilized netbeans java swing form
 */
 import java.lang.*;

import java.util.*;
import java.io.*;

public class bfsJframe extends javax.swing.JFrame {

    /**
     * Creates new form bfsJframe
     */
    public bfsJframe() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jComboBox1 = new javax.swing.JComboBox();
		
		jTextTruthTable = new javax.swing.JTextArea();
		jTextSearching = new javax.swing.JTextArea();
		jTextSolutions = new javax.swing.JTextArea();
		
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

		// entire text area
        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
		
		// text area for truth table
		jTextTruthTable.setColumns(8);
		jTextTruthTable.setRows(5);
		
		// text area for searching
		jTextSearching.setColumns(12);
		jTextSearching.setRows(5);
		
		// text area for solutions
		jTextSolutions.setColumns(10);
		jTextSolutions.setRows(5);
		
		// set view port for text areas
        jScrollPane1.setViewportView(jTextArea1);
		//jScrollPane1.setViewportView(jTextTruthTable);
		//jScrollPane1.setViewportView(jTextSearching);
		//jScrollPane1.setViewportView(jTextSolutions);
		
        jLabel1.setText("TEAM 1 - BFS");

        jButton1.setText("Run");
		
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Full Adder", "XOR", "Inverter" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 678, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(1, 1, 1))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(23, 23, 23))
        );
        
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 378, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(26, 26, 26))
        );

        pack();
    }// </editor-fold>                        

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {                                           
        // TODO add your handling code here:
        
        //if(evt.getStateChange() == "")
    }                                          

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
		
		String action = jComboBox1.getSelectedItem().toString();

		
		if(action.equals("Full Adder")){
		jTextArea1.setText("Running Full Adder...\n");
			//jTextArea1.validate();
			
			//jTextArea1.revalidate();
		//	jTextArea1.repaint();
			jScrollPane1.validate();
				jTextArea1.append("A | B | C || 1 | 2 )\n" + 
							  "------------------------\n" +
								  "0 | 0 | 0 || 0 | 0 \n" +
							      "0 | 0 | 1 || 0 | 1 \n" +
							      "0 | 1 | 0 || 0 | 1 \n" +
							      "0 | 1 | 1 || 1 | 0\n" +
							      "1 | 0 | 0 || 0 | 1 \n" +
							      "1 | 0 | 1 || 1 | 0 \n" +
							      "1 | 1 | 0 || 1 | 0 \n" +
							      "1 | 1 | 1 || 1 | 1 \n\n" 
							  );
				jTextArea1.update(jTextArea1.getGraphics());
			
			//circuit_inputs
				ArrayList<String> circuit_input = new ArrayList<String>();
			
				// 2 input truth table
				circuit_input.add("00001111");
				circuit_input.add("00110011");
				circuit_input.add("01010101");
			
				//circuit solutions
				ArrayList<String> circuit_solutions = new ArrayList<String>();
				circuit_solutions.add("00010111");
				circuit_solutions.add("01101001");
				
				int not_gates_allowed = 2;
				BFS n = new BFS();
				/* try{
				Circuit test = n.bfsAlgorithm(circuit_input, circuit_solutions, 2);
				}
				catch(IOException ioe){
				} */
			ArrayList<String> start_circuit_lines = new ArrayList<String>();
			for (int i = 1; i <= circuit_input.size(); ++i) {
				start_circuit_lines.add(i + " NONE " + i);
			}
			ArrayList<Integer> input_solution_lines = new ArrayList<Integer>();
			Circuit start_circuit = new Circuit(start_circuit_lines, 0, circuit_input, not_gates_allowed, circuit_solutions, input_solution_lines); // this should initialize the first
											 
			Queue<Circuit> q = new LinkedList<Circuit>();
			q.add(start_circuit);
			boolean not_found = true;
			Circuit current_circuit;
			int count = 0;
			while ((current_circuit = q.poll()) != null && not_found  ) {
				try{
					ArrayList<Circuit> children = new ArrayList<Circuit>(current_circuit.getPossibleGates() ); // level to search through
					++count;
					jTextArea1.append("Searching Circuit: " + count+ 
									 "\n");
			
					
					for (Circuit c : children) {
					
					if (c.solution_lines.size() == circuit_solutions.size()) {
						jTextArea1.append("_____________________________\n\n\n");
						jTextArea1.append("Solution line(s) are on:\n");
						for(int b = 0; b < c.solution_lines.size(); ++b)
							jTextArea1.append("line:  " + c.solution_lines.get(b) +"\n");
							jTextArea1.append("\n\n");
						for(int h = 0 ; h < c.circuit.size();++h){
							jTextArea1.append( c.circuit.get(h) + "\n" );
						}
						not_found = false;
						break;
						//return c;
					}
					else {
						q.add(c); // pushes current circuit into q
					}  
				}
				}
				catch(IOException ioe){
					
				}
			}
		}
		else if(action.equals("XOR")){
			
			jTextArea1.setText("Running XOR...\n\n");
			jTextArea1.repaint();
			jScrollPane1.repaint();
			jTextArea1.append("A | B || 1\n" + 
							  "----------\n" +
							  "0 | 0 || 0\n" +
							  "1 | 0 || 1\n" +
							  "0 | 1 || 1\n" +
							  "1 | 1 || 0\n\n" 
							  );
		//	jTextArea1.repaint();
		//circuit_inputs
			ArrayList<String> circuit_input = new ArrayList<String>();
        
			// 2 input truth table
			circuit_input.add("0011");
			circuit_input.add("0101");
        
			//circuit solutions
			ArrayList<String> circuit_solutions = new ArrayList<String>();
			circuit_solutions.add("0110");
			int not_gates_allowed = 1;
        
			ArrayList<String> start_circuit_lines = new ArrayList<String>();
        for (int i = 1; i <= circuit_input.size(); ++i) {
            start_circuit_lines.add(i + " NONE " + i);
        }
        ArrayList<Integer> input_solution_lines = new ArrayList<Integer>();
        Circuit start_circuit = new Circuit(start_circuit_lines, 0, circuit_input, not_gates_allowed, circuit_solutions, input_solution_lines); // this should initialize the first
                                         
        Queue<Circuit> q = new LinkedList<Circuit>();
        q.add(start_circuit);
        boolean not_found = true;
        Circuit current_circuit;
		int count = 0;
        while ((current_circuit = q.poll()) != null && not_found) {
            try{
				ArrayList<Circuit> children = new ArrayList<Circuit>(current_circuit.getPossibleGates() ); // level to search through
				++count;
				jTextArea1.append("Searching Circuit: " + count+ 
								  "\n");
				for (Circuit c : children) {
				
                if (c.solution_lines.size() == circuit_solutions.size()) {
					jTextArea1.append("_____________________________\n\n\n");
					jTextArea1.append("Solution line(s) are on:\n");
				//	jTextArea1.repaint();
					for(int b = 0; b < c.solution_lines.size(); ++b){
						jTextArea1.append("line:  " + c.solution_lines.get(b) +"\n");
					//	jTextArea1.repaint();
					}
						jTextArea1.append("\n\n");
					//	jTextArea1.repaint();
					for(int h = 0 ; h < c.circuit.size();++h){
						jTextArea1.append( c.circuit.get(h) + "\n" );
					//	jTextArea1.repaint();
					}
					not_found = false;
					break;
                    //return c;
                }
                else {
                    q.add(c); // pushes current circuit into q
                }  
            }
			}
			catch(IOException ioe){
				
			}
            
        }
        //return null;
		
			
			/* jTextArea1.append("Searching Circuit: 1\n" + 
								  "At Level: \n\n"); */
								  
			
			
			
			
		}
		else if(action.equals("Inverter")){
			jTextArea1.setText("Running Inverter...\n");
			//jTextArea1.validate();
			
			//jTextArea1.revalidate();
		//	jTextArea1.repaint();
			jScrollPane1.validate();
				jTextArea1.append("A | B | C || 1 | 2 | 3 |)\n" + 
							  "------------------------\n" +
								  "0 | 0 | 0 || 1 | 1 | 1\n" +
							      "0 | 0 | 1 || 1 | 1 | 0\n" +
							      "0 | 1 | 0 || 1 | 0 | 1\n" +
							      "0 | 1 | 1 || 1 | 0 | 0\n" +
							      "1 | 0 | 0 || 0 | 1 | 1\n" +
							      "1 | 0 | 1 || 0 | 1 | 0\n" +
							      "1 | 1 | 0 || 0 | 0 | 1 \n" +
							      "1 | 1 | 1 || 0 | 0 | 0\n\n" 
							  );
				jTextArea1.update(jTextArea1.getGraphics());
			
			//circuit_inputs
				ArrayList<String> circuit_input = new ArrayList<String>();
			
				// 2 input truth table
				circuit_input.add("00001111");
				circuit_input.add("00110011");
				circuit_input.add("01010101");
			
				//circuit solutions
				ArrayList<String> circuit_solutions = new ArrayList<String>();
				circuit_solutions.add("11110000");
				circuit_solutions.add("11001100");
				circuit_solutions.add("10101010");
				int not_gates_allowed = 2;
				BFS n = new BFS();
				/* try{
				Circuit test = n.bfsAlgorithm(circuit_input, circuit_solutions, 2);
				}
				catch(IOException ioe){
				} */
			ArrayList<String> start_circuit_lines = new ArrayList<String>();
			for (int i = 1; i <= circuit_input.size(); ++i) {
				start_circuit_lines.add(i + " NONE " + i);
			}
			ArrayList<Integer> input_solution_lines = new ArrayList<Integer>();
			Circuit start_circuit = new Circuit(start_circuit_lines, 0, circuit_input, not_gates_allowed, circuit_solutions, input_solution_lines); // this should initialize the first
											 
			Queue<Circuit> q = new LinkedList<Circuit>();
			q.add(start_circuit);
			boolean not_found = true;
			Circuit current_circuit;
			int count = 0;
			while ((current_circuit = q.poll()) != null && not_found  ) {
				try{
					ArrayList<Circuit> children = new ArrayList<Circuit>(current_circuit.getPossibleGates() ); // level to search through
					++count;
					jTextArea1.append("Searching Circuit: " + count+ 
									 "\n");
			
					
					for (Circuit c : children) {
					
					if (c.solution_lines.size() == circuit_solutions.size()) {
						jTextArea1.append("_____________________________\n\n\n");
						jTextArea1.append("Solution line(s) are on:\n");
						for(int b = 0; b < c.solution_lines.size(); ++b)
							jTextArea1.append("line:  " + c.solution_lines.get(b) +"\n");
							jTextArea1.append("\n\n");
						for(int h = 0 ; h < c.circuit.size();++h){
							jTextArea1.append( c.circuit.get(h) + "\n" );
						}
						not_found = false;
						break;
						//return c;
					}
					else {
						q.add(c); // pushes current circuit into q
					}  
				}
				}
				catch(IOException ioe){
					
				}
			} 
				
		}
		else{
				jTextArea1.setText("An unknown error occurred...");
			}
	                                        
	}
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(bfsJframe.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(bfsJframe.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(bfsJframe.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(bfsJframe.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new bfsJframe().setVisible(true);
            }
        });
    }

    

    // Variables declaration - do not modify                     
    private javax.swing.JButton jButton1;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
	
	private javax.swing.JTextArea jTextTruthTable;
	private javax.swing.JTextArea jTextSearching;
	private javax.swing.JTextArea jTextSolutions;
    // End of variables declaration                   
}
